\documentclass[10pt]{article}
%\VignetteIndexEntry{Rcpp-sugar}
\usepackage{vmargin}
\setmargrb{0.75in}{0.75in}{0.75in}{0.75in}

\usepackage{color, alltt}
\usepackage[authoryear,round,longnamesfirst]{natbib}
\usepackage[colorlinks]{hyperref}
\definecolor{link}{rgb}{0,0,0.3}	%% next few lines courtesy of RJournal.sty
\hypersetup{
    colorlinks,%
    citecolor=link,%
    filecolor=link,%
    linkcolor=link,%
    urlcolor=link
}

\newcommand{\proglang}[1]{\textsf{#1}}
\newcommand{\pkg}[1]{{\fontseries{b}\selectfont #1}}
\newcommand{\sugar}{\textsl{Rcpp sugar}}

\author{Dirk Eddelbuettel \and Romain Fran\c{c}ois}
\title{\pkg{Rcpp} syntactic sugar}

<<echo=FALSE>>=
link <- function( f, package, text = f, root = "http://finzi.psych.upenn.edu/R/library/" ){
	h <- if( missing(package) ) {
		as.character( help( f ) )
	} else {
		as.character( help( f, package = paste( package, sep = "" ) ) )
	}
	if( ! length(h) ){
		sprintf( "\\\\textbf{%s}", f )
	} else {
		rx <- "^.*/([^/]*?)/help/(.*?)$"
		package <- sub( rx, "\\1", h, perl = TRUE )
		page <- sub( rx, "\\2", h, perl = TRUE )
		sprintf( "\\\\href{%s%s/html/%s.html}{\\\\texttt{%s}}", root, package, page, text )
	}
}
linkS4class <- function( cl, package, text = cl, root = "http://finzi.psych.upenn.edu/R/library/" ){
	link( sprintf("%s-class", cl), package, text, root )
}
@

\begin{document}
\maketitle

\abstract{
  \noindent
  This note describes \sugar~which has been introduced in
  version 0.8.3 of \pkg{Rcpp} \citep{CRAN:Rcpp}. \sugar~
  offers to bring a higher-level of abstraction to \proglang{C++} code
  written using the \pkg{Rcpp} API.

  \sugar~is based on expression templates
  \citep{Abrahams+Gurtovoy:2004,Vandevoorde+Josuttis:2003} and provides
  some 'syntactic sugar' facilities directly in \pkg{Rcpp} which is similar
  to the classes \pkg{RcppArmadillo} \citep{CRAN:RcppArmadillo} offered for
  linear algebra \proglang{C++} classes based on \pkg{Armadillo}
  \citep{Armadillo}.
  % TODO: reference to armadillo, blitz, etc ...
}

\section{Motivation}

\pkg{Rcpp} facilitates development of internal compiled code in an \proglang{R}
package by abstracting low-level details of the \proglang{R} API \citep{R:exts}
into a consistent set of \proglang{C++} classes.

Code written using \pkg{Rcpp} classes is easier to read, write and maintain,
without loosing performance. Consider the following code:

<<lang=cpp>>=
RcppExport SEXP foo( SEXP x, SEXP y){
    Rcpp::NumericVector xx(x) ;
    Rcpp::NumericVector yy(y) ;
    int n = xx.size() ;
    Rcpp::NumericVector res( n ) ;
    double x_ = 0.0 ;
    double y_ = 0.0 ;
    for( int i=0; i<n; i++){
        x_ = xx[i] ;
        y_ = yy[i] ;
        if( x_ < y_ ){
            res[i] = x_ * x_ ;
        } else {
            res[i] = -( y_ * y_)  ;
        }
    }
    return res ;
}
@

The aim of the \texttt{foo} code is simple. Given two \texttt{numeric} vectors,
we create a third one. This is typical low-level \proglang{C++} code that
that would be written much more consicely in \proglang{R} thanks to vectorisation.

<<eval=FALSE>>=
foo <- function(x, y){
	ifelse( x < y, x*x, -(y*y) )
}
@

The motivation of \sugar~is to bring a subset of the high-level \proglang{R}
syntax in \proglang{C++}. With \sugar, the \proglang{C++} version of
\texttt{foo} becomes:

<<lang=cpp>>=
RcppExport SEXP foo( SEXP x, SEXP y){
    Rcpp::NumericVector xx(x) ;
    Rcpp::NumericVector yy(y) ;
    Rcpp::NumericVector res = ifelse( xx < yy, xx*xx, -(yy*yy) ) ;
    return res ;
}
@

\sugar~is written using expression templates and lazy evaluation techniques,
which not only allows a much nicer high-level syntax, but also makes it
very efficient (as we detail in section~\ref{sec:performance} below).

\section{Operators}

\sugar~takes advantage of \proglang{C++} operator overloading.

\subsection{binary arithmetic operators}

\sugar~defines the usual binary arithmetic operators : \texttt{+}, \texttt{-},
\texttt{*}, \texttt{/}. 

<<lang=cpp>>=
// two numeric vectors of the same size
NumericVector x ;
NumericVector y ;

// expressions involving two vectors
NumericVector res = x + y ;
NumericVector res = x - y ;
NumericVector res = x * y ;
NumericVector res = x / y ;

// one vector, one single value
NumericVector res = x + 2.0 ;
NumericVector res = 2.0 - x;
NumericVector res = y * 2.0 ;
NumericVector res = 2.0 / y;

// two expressions
NumericVector res = x * y + y / 2.0 ;
NumericVector res = x * ( y - 2.0 ) ;
NumericVector res = x / ( y * y ) ;
@

The left hand side (lhs) and the right hand side (rhs) of each binary 
arithmetic expression must be of the same type (for example they should be both
\texttt{numeric} expressions). 

The lhs and the rhs can either have the same size or one of them could 
be a primitive value of the appropriate type, for example adding a 
\texttt{NumericVector} and a \texttt{double}. 

\subsection{binary logical operators}

Binary logical operators create a \texttt{logical} sugar expression
from either two sugar expressions of the same type or one sugar expression
and a primitive value of the associated type. 

<<lang=cpp>>=
// two integer vectors of the same size
NumericVector x ;
NumericVector y ;

// expressions involving two vectors
LogicalVector res = x < y ;
LogicalVector res = x > y ;
LogicalVector res = x <= y ;
LogicalVector res = x >= y ;
LogicalVector res = x == y ;
LogicalVector res = x != y ;

// one vector, one single value
LogicalVector res = x < 2 ;
LogicalVector res = 2 > x;
LogicalVector res = y <= 2 ;
LogicalVector res = 2 != y;

// two expressions
LogicalVector res = ( x + y ) <  ( x*x ) ;
LogicalVector res = ( x + y ) >= ( x*x ) ;
LogicalVector res = ( x + y ) == ( x*x ) ;
@

\subsection{Unary operators}

\subsubsection{operator-}

The unary \texttt{operator-} can be used to negate a sugar expression.

<<lang=cpp>>=
// a numeric vector
NumericVector x ;

// negate x
NumericVector res = -x ;

// use it as part of an expression
NumericVector res = -x * ( x + 2.0 ) ;
@

\subsubsection{operator!}

The unary \texttt{operator!} negates a logical sugar expression: 

<<lang=cpp>>=
// two integer vectors of the same size
NumericVector x ;
NumericVector y ;

// negate the expression "x < y"
LogicalVector res = ! ( x < y );
@

\section{Functions}
      
\sugar~defines functions that closely match the behavior of \proglang{R}
functions of the same name. 

\subsection{Functions producing a single logical result}

\subsubsection{all}

Given a logical sugar expression, identifies if all the elements are
\texttt{TRUE}. This respects \proglang{R} missing values. 

<<lang=cpp>>=
IntegerVector x = seq_len( 1000 ) ;
all( x*x < 3 ) ;
@

This creates an object of a class that has member functions \texttt{is\_true}, 
\texttt{is\_false}, \texttt{is\_na} and a conversion to \texttt{SEXP} operator. 

One important thing to highlight is that \texttt{all} is lazy. Unlike R, 
there is no need to fully evaluate the expression. In the example above, 
the result of \texttt{all} is fully resolved after evaluating only the two 
first indices of the expression \verb|xx * xx < 3|.

\subsubsection{any}

Given a logical sugar expression, identifies if any the element is
\texttt{TRUE}. This respects \proglang{R} missing values. 

<<lang=cpp>>=
IntegerVector x = seq_len( 1000 ) ;
any( x*x < 3 ) ;
@

\texttt{any} is lazy too, so it will only need to resolve the first element
of the example above. 

\subsection{Functions producing sugar expressions}

\subsubsection{is\_na}

Given a sugar expression of any type, \texttt{is\_na} produces a logical
sugar expression of the same length. Each element of the result expression
evaluates to \texttt{TRUE} if the corresponding input is a missing value, or
\texttt{FALSE} otherwise.

<<lang=cpp>>=
IntegerVector x = IntegerVector::create( 0, 1, NA_INTEGER, 3 ) ;

is_na( x )
all( is_na( x ) )
any( ! is_na( x ) )
@

\subsubsection{seq\_along}

Given a sugar expression of any type, \texttt{seq\_len} creates an 
integer sugar expression whose values go from 1 to the sire of the input.

<<lang=cpp>>=
IntegerVector x = IntegerVector::create( 0, 1, NA_INTEGER, 3 ) ;

seq_along( x )
seq_along( x * x * x * x * x * x * x )
@

This is the most lazy function, as it only needs to call the \texttt{size}
member function of the input expression. The input expression need not to be 
resolved. The two examples above gives the same result with the same efficiency
at runtime. The compile time will be affected by the complexity of the 
second expression, since the abstract syntax tree is built at compile time.

\subsubsection{seq\_len}

\texttt{seq\_len} creates an integer sugar expression whose i-th
element expands to \texttt{i}. \texttt{seq\_len} is particularly useful in 
conjunction with \texttt{sapply} and \texttt{lapply}. 

<<lang=cpp>>=
// 1, 2, ..., 10
IntegerVector x = seq_len( 10 ) ;

lapply( seq_len(10), seq_len )
@

\subsubsection{pmin}

Given two sugar expressions of the same type and size, or one expression and
one primitive value of the appropriate type, \texttt{pmin} generates a sugar
expression of the same type whose i\textsuperscript{th} element expands to the 
lowest value between the i\textsuperscript{th} element of the first expression 
and the i\textsuperscript{th} element of the second expression.

<<lang=cpp>>=
IntegerVector x = seq_len( 10 ) ;

pmin( x, x*x )
pmin( x*x, 2 )
@

\subsubsection{pmax}

Given two sugar expressions of the same type and size, or one expression and
one primitive value of the appropriate type, \texttt{pmax} generates a sugar
expression of the same type whose i\textsuperscript{th} element expands to the 
greatest value between the i\textsuperscript{th} element of the first expression 
and the i\textsuperscript{th} element of the second expression.

<<lang=cpp>>=
IntegerVector x = seq_len( 10 ) ;

pmin( x, x*x )
pmin( x*x, 2 )
@


\subsubsection{sapply}
\subsubsection{lapply}
\subsubsection{ifelse}

\section{Performance}
\label{sec:performance}

\section{Implementation}

\bibliographystyle{abbrvnat}
\bibliography{Rcpp}

\end{document}

