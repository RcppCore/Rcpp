\documentclass[10pt]{article}
%\VignetteIndexEntry{Rcpp-sugar}
\usepackage{vmargin}
\setmargrb{0.75in}{0.75in}{0.75in}{0.75in}

\usepackage{color, alltt}
\usepackage[authoryear,round,longnamesfirst]{natbib}
\usepackage[colorlinks]{hyperref}
\definecolor{link}{rgb}{0,0,0.3}	%% next few lines courtesy of RJournal.sty
\hypersetup{
    colorlinks,%
    citecolor=link,%
    filecolor=link,%
    linkcolor=link,%
    urlcolor=link
}

\newcommand{\proglang}[1]{\textsf{#1}}
\newcommand{\pkg}[1]{{\fontseries{b}\selectfont #1}}
\newcommand{\sugar}{\textsl{Rcpp sugar}}

\author{Dirk Eddelbuettel \and Romain Fran\c{c}ois}
\title{\pkg{Rcpp} syntactic sugar}

<<echo=FALSE>>=
link <- function( f, package, text = f, root = "http://finzi.psych.upenn.edu/R/library/" ){
	h <- if( missing(package) ) {
		as.character( help( f ) )
	} else {
		as.character( help( f, package = paste( package, sep = "" ) ) )
	}
	if( ! length(h) ){
		sprintf( "\\\\textbf{%s}", f )
	} else {
		rx <- "^.*/([^/]*?)/help/(.*?)$"
		package <- sub( rx, "\\1", h, perl = TRUE )
		page <- sub( rx, "\\2", h, perl = TRUE )
		sprintf( "\\\\href{%s%s/html/%s.html}{\\\\texttt{%s}}", root, package, page, text )
	}
}
linkS4class <- function( cl, package, text = cl, root = "http://finzi.psych.upenn.edu/R/library/" ){
	link( sprintf("%s-class", cl), package, text, root )
}
@

\begin{document}
\maketitle

\abstract{
  \noindent
  This note describes \sugar~which has been introduced in
  version 0.8.3 of \pkg{Rcpp} \citep{CRAN:Rcpp}. \sugar~
  offers to bring a higher-level of abstraction to \proglang{C++} code
  written using the \pkg{Rcpp} API.

  \sugar~is based on expression templates
  \citep{Abrahams+Gurtovoy:2004,Vandevoorde+Josuttis:2003} and provides
  some 'syntactic sugar' facilities directly in \pkg{Rcpp} which is similar
  to the classes \pkg{RcppArmadillo} \citep{CRAN:RcppArmadillo} offered for
  linear algebra \proglang{C++} classes based on \pkg{Armadillo}
  \citep{Armadillo}.
  % TODO: reference to armadillo, blitz, etc ...
}

\section{Motivation}

\pkg{Rcpp} facilitates development of internal compiled code in an \proglang{R}
package by abstracting low-level details of the \proglang{R} API \citep{R:exts}
into a consistent set of \proglang{C++} classes.

Code written using \pkg{Rcpp} classes is easier to read, write and maintain,
without loosing performance. Consider the following code:

<<lang=cpp>>=
RcppExport SEXP foo( SEXP x, SEXP y){
    Rcpp::NumericVector xx(x) ;
    Rcpp::NumericVector yy(y) ;
    int n = xx.size() ;
    Rcpp::NumericVector res( n ) ;
    double x_ = 0.0 ;
    double y_ = 0.0 ;
    for( int i=0; i<n; i++){
        x_ = xx[i] ;
        y_ = yy[i] ;
        if( x_ < y_ ){
            res[i] = x_ * x_ ;
        } else {
            res[i] = -( y_ * y_)  ;
        }
    }
    return res ;
}
@

The aim of the \texttt{foo} code is simple. Given two \texttt{numeric} vectors,
we create a third one. This is typical low-level \proglang{C++} code that
that would be written much more consicely in \proglang{R} thanks to vectorisation.

<<eval=FALSE>>=
foo <- function(x, y){
	ifelse( x < y, x*x, -(y*y) )
}
@

The motivation of \sugar~is to bring a subset of the high-level \proglang{R}
syntax in \proglang{C++}. With \sugar, the \proglang{C++} version of
\texttt{foo} becomes:

<<lang=cpp>>=
RcppExport SEXP foo( SEXP x, SEXP y){
    Rcpp::NumericVector xx(x) ;
    Rcpp::NumericVector yy(y) ;
    Rcpp::NumericVector res = ifelse( xx < yy, xx*xx, -(yy*yy) ) ;
    return res ;
}
@

\sugar~is written using expression templates and lazy evaluation techniques,
which not only allows a much nicer high-level syntax, but also makes it
very efficient (as we detail in section~\ref{sec:performance} below).

\section{Operators}

\sugar~takes advantage of \proglang{C++} operator overloading.

\subsection{binary arithmetic operators}

\sugar~defines the usual binary arithmetic operators : \texttt{+}, \texttt{-},
\texttt{*}, \texttt{/}. 

<<lang=cpp>>=
// two numeric vectors of the same size
NumericVector x ;
NumericVector y ;

// expressions involving two vectors
NumericVector res = x + y ;
NumericVector res = x - y ;
NumericVector res = x * y ;
NumericVector res = x / y ;

// one vector, one single value
NumericVector res = x + 2.0 ;
NumericVector res = 2.0 - x;
NumericVector res = y * 2.0 ;
NumericVector res = 2.0 / y;

// two expressions
NumericVector res = x * y + y / 2.0 ;
NumericVector res = x * ( y - 2.0 ) ;
NumericVector res = x / ( y * y ) ;
@

The left hand side (lhs) and the right hand side (rhs) of each binary 
arithmetic expression must be of the same type (for example they should be both
\texttt{numeric} expressions). 

The lhs and the rhs can either have the same size or one of them could 
be a primitive value of the appropriate type, for example adding a 
\texttt{NumericVector} and a \texttt{double}. 

\subsection{binary logical operators}

\subsubsection{operator<}
\subsubsection{operator>}
\subsubsection{operator<=}
\subsubsection{operator>=}
\subsubsection{operator==}
\subsubsection{operator!=}

\subsection{Unary operators}

\subsubsection{operator-}
\subsubsection{operator!}

\section{Functions}

\subsection{all}
\subsection{any}
\subsection{is na}
\subsection{ifelse}
\subsection{seq along}
\subsection{seq len}
\subsection{pmin}
\subsection{pmax}
\subsection{sapply}
\subsection{lapply}

\section{Performance}
\label{sec:performance}

\section{Implementation}

\bibliographystyle{abbrvnat}
\bibliography{Rcpp}

\end{document}

