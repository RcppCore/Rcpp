\documentclass[10pt]{article}
%\VignetteIndexEntry{Rcpp-modules}
\usepackage{vmargin}
\setmargrb{0.75in}{0.75in}{0.75in}{0.75in}

\usepackage{color, alltt}
\usepackage[authoryear,round,longnamesfirst]{natbib}
\usepackage[colorlinks]{hyperref}
\definecolor{link}{rgb}{0,0,0.3}	%% next few lines courtesy of RJournal.sty
\hypersetup{
    colorlinks,%
    citecolor=link,%
    filecolor=link,%
    linkcolor=link,%
    urlcolor=link
}

\newcommand{\proglang}[1]{\textsf{#1}}
\newcommand{\pkg}[1]{{\fontseries{b}\selectfont #1}}

\author{Dirk Eddelbuettel \and Romain Fran\c{c}ois}
\title{Exposing \proglang{C++} functions and classes with \pkg{Rcpp} modules}

<<echo=FALSE>>=
link <- function( f, package, text = f, root = "http://finzi.psych.upenn.edu/R/library/" ){
	h <- if( missing(package) ) {
		as.character( help( f ) )
	} else {
		as.character( help( f, package = paste( package, sep = "" ) ) )
	}
	if( ! length(h) ){
		sprintf( "\\\\textbf{%s}", f )
	} else {
		rx <- "^.*/([^/]*?)/help/(.*?)$"
		package <- sub( rx, "\\1", h, perl = TRUE )
		page <- sub( rx, "\\2", h, perl = TRUE )
		sprintf( "\\\\href{%s%s/html/%s.html}{\\\\texttt{%s}}", root, package, page, text )
	}
}
linkS4class <- function( cl, package, text = cl, root = "http://finzi.psych.upenn.edu/R/library/" ){
	link( sprintf("%s-class", cl), package, text, root )
}
@

\begin{document}
\maketitle

\abstract{
  \noindent
  This note discusses \textsl{Rcpp modules} which have been introduced in
  version 0.8.1 of the \pkg{Rcpp} package.  \textsl{Rcpp modules} allow programmers to
  expose \proglang{C++} functions and classes to \proglang{R} with relative
  ease.  \textsl{Rcpp modules} are inspired from the \texttt{Boost.Python}
  \proglang{C++} library \citep{Abrahams+Grosse-Kunstleve:2003:Boost.Python} which provides the same
  features (and much more) for Python.
}

\section{Motivation}

Exposing \proglang{C++} functionality to \proglang{R} is greatly facilitated
by the \pkg{Rcpp} package and underlying \proglang{C++} library
\citep{CRAN:Rcpp}. \pkg{Rcpp} smoothes many of the rough edges in
\proglang{R} and \proglang{C++} integration by replacing the traditional
\proglang{R} API \citep{R:Extensions} with a consistent set of \proglang{C++}
classes.

However, these facilities are limited to a function by function basis. The
programmer has to implement a \Sexpr{link(".Call")} compatible function
using classes of the \pkg{Rcpp} API.

\subsection{Exposing functions}

Exposing existing \proglang{C++} functions to \proglang{R} through \pkg{Rcpp}
usually involves several steps. One often writes either an additional wrapper
function that is responsible for converting input objects to the appropriate
types, calling the actual worker function and converting the results back to
a suitable type that can be returned to R. Alternatively, one can alter the
worker function by changes to its signature and return value of the interface
prescribed by the \texttt{.Call()} function of the \proglang{R} API. The
return type has to the traditional \texttt{SEXP} from the \proglang{R}
API. But with \pkg{Rcpp} we can also use one of the many types from the
\pkg{Rcpp} API that offers implicit conversion to \texttt{SEXP}.

Consider the \texttt{hello} function below:

<<lang=cpp>>=
const char* hello( std::string who ){
	std::string result( "hello " ) ;
	result += who ;
	return result.c_str() ;
}
@

One can expose a such a function using \pkg{Rcpp} converters

<<lang=cpp>>=
RcppExport SEXP hello_wrapper( SEXP who){
    std::string input = Rcpp::as<std::string>( who )
    const char* result = hello( input ) ;
    return Rcpp::wrap( result );
}
@

Here we use the (templated) \pkg{Rcpp} converter \texttt{as()} which can
transform from a \texttt{SEXP} to a number of different \proglang{C++} and
\pkg{Rcpp} types. The \pkg{Rcpp} function \texttt{wrap()} offers the opposite
functionality and converts many known types to a \texttt{SEXP}.

For comparison, the traditionally approach using the \proglang{R} API looks similar

<<lang=cpp>>=
extern "C" SEXP hello_wrapper( SEXP who){
    std::string input = CHAR(STRING_ELT(input,0)) ;
    const char* result = hello( input ) ;
    return mkString( result );
}
@

Either way requires direct involvement from the programmer. This quickly
becomes a time sink when many functions are involved. \textsl{Rcpp modules}
provides a much more efficient way to expose the \texttt{hello} function to \proglang{R}.

\subsection{Exposing classes}

Exposing \proglang{C++} classes or structs is even more of a challenge because it
requires writing glue code for each member function that is to be exposed. Consider the
simple \texttt{World} class below:

<<lang=cpp>>=
class World {
public:
    World() : msg("hello"){}
    void set(std::string msg) { this->msg = msg; }
    std::string greet() { return msg; }

private:
    std::string msg;
};
@

We might want a way to create objects of this class, and use the member
functions \texttt{greet} and \texttt{set} to alter the object. External pointers
\citep{R:Extensions} are the perfect vessel for this, and using the
\texttt{Rcpp:::XPtr} template from \pkg{Rcpp} we can expose the class
by exposing three functions :

<<lang=cpp>>=
using namespace Rcpp ;

/** create an external pointer to a World object */
RcppExport SEXP World__new(){
	return Rcpp::XPtr<World>( new World, true ) ;
}

/** invoke the greet method */
RcppExport SEXP World__greet( SEXP xp ) {
	Rcpp::XPtr<World> w(xp) ;
	return Rcpp::wrap( w->greet() ) ;
}

/** invoke the set method */
RcppExport SEXP World__set( SEXP xp, SEXP msg ){
	Rcpp::XPtr<World> w(xp) ;
	w->set( Rcpp::as<std::string>( msg ) ) ;
	return R_NilValue ;
}
@

which can be used from \proglang{R} with some S4 glue code:

<<eval=FALSE>>=
setClass( "World", representation( pointer = "externalptr" ) )

World_method <- function(name){
	paste( "World", name, sep = "__" )
}

setMethod( "$", "World", function(x, name ){
	function(...) .Call( World_method(name) , x@pointer, ... )
} )

w <- new( "World", .Call( World_method( "new" ) ) )
w$set( "hello world" )
w$greet()
@

\pkg{Rcpp} considerably simplifies the code that would be involved for using
external pointers with the traditional \proglang{R} API. This still involves
a lot of pattern code that quickly becomes hard to maintain and error prone.
\textsl{Rcpp modules} offer a much nicer way to expose the \texttt{World}
class in a way that makes both the internal \proglang{C++} code and the \proglang{R} code easier.

\section{Rcpp modules}

Rcpp modules are inspired from Python modules that are generated by the
\texttt{Boost.Python} library \citep{Abrahams+Grosse-Kunstleve:2003:Boost.Python}. They provide an easy way
to expose \proglang{C++} functions and classes to \proglang{R}, grouped
together in a single entity.

The module is created in a \texttt{cpp} file using the \texttt{RCPP\_MODULE}
macro, which then contains declarative code of what the module
exposes to \proglang{R}.

\subsection{Exposing \proglang{C++} functions}

Consider the \texttt{hello} function from the previous section.
We can expose it to \proglang{R} :

<<lang=cpp>>=
const char* hello( std::string who ){
	std::string result( "hello " ) ;
	result += who ;
	return result.c_str() ;
}

RCPP_MODULE(yada){
	using namespace Rcpp ;
	function( "hello", &hello ) ;
}
@

The code creates an Rcpp module called \texttt{yada}
that exposes the \texttt{hello} function. \pkg{Rcpp} automatically
deduces the conversions that are needed for input and output. This alleviates
the need for a wrapper function using either \pkg{Rcpp} or the \proglang{R} API.

On the \proglang{R} side, the module is simply retrieved by using the
\Sexpr{link("Module")} function from \pkg{Rcpp}:

<<eval=FALSE>>=
require( Rcpp )
yada <- Module( "yada" )
yada$hello( "world" )
@

A module can contain any number of calls to \texttt{function} to register
many internal functions to \proglang{R}. For example, these 6 functions :

<<lang=cpp>>=
std::string hello(){
	return "hello" ;
}

int bar( int x){
	return x*2 ;
}

double foo( int x, double y){
	return x * y ;
}

void bla( ){
	Rprintf( "hello\\n" ) ;
}

void bla1( int x){
	Rprintf( "hello (x = %d)\\n", x ) ;
}

void bla2( int x, double y){
	Rprintf( "hello (x = %d, y = %5.2f)\\n", x, y ) ;
}
@

can be exposed with the following minimal code:

<<lang=cpp>>=
RCPP_MODULE(yada){
    using namespace Rcpp ;

    function( "hello" , &hello ) ;
    function( "bar"   , &bar   ) ;
    function( "foo"   , &foo   ) ;
    function( "bla"   , &bla   ) ;
    function( "bla1"  , &bla1   ) ;
    function( "bla2"  , &bla2   ) ;
}
@

and used from \proglang{R}:

<<eval=FALSE>>=
require( Rcpp )

yada <- Module( "yada" )
yada$bar( 2L )
yada$foo( 2L, 10.0 )
yada$hello()
yada$bla()
yada$bla1( 2L)
yada$bla2( 2L, 5.0 )
@

The requirements on the functions to be exposed are:
\begin{itemize}
\item It takes between 0 and 65 parameters.
\item The type of each input parameter must be manageable by the \texttt{Rcpp::as}
template.
\item The output type must be either \texttt{void} or any type that
can be managed by the \texttt{Rcpp::wrap} template.
\item The function name itself has to be unique, in other words no two functions with
  the same name but different signatures itself are allowed (whereas this is
  possible in \proglang{C++} itself).
\end{itemize}

\subsection{Exposing \proglang{C++} classes}

Rcpp modules also provide a mechanism for exposing \proglang{C++} classes. The mechanism
internally uses external pointers, but the user should consider this as
hidden implementation details as this is properly encapsulated.

A class is exposed using the \texttt{class\_} class. The \texttt{World}
class may be exposed to \proglang{R} :

<<lang=cpp>>=
class World {
public:
    World() : msg("hello"){}
    void set(std::string msg) { this->msg = msg; }
    std::string greet() { return msg; }

private:
    std::string msg;
};

void clearWorld( World* w){
	w->set( "" ) ;
}

RCPP_MODULE(yada){
	using namespace Rcpp ;

	class_<World>( "World" )
		.method( "greet", &World::greet )
		.method( "set", &World::set )
		.method( "clear", &clearWorld )
	;

}
@

\texttt{class\_} is templated by the \proglang{C++} class or struct that is to be exposed
to \proglang{R}. The parameter of the \texttt{class\_<World>} constructor is the name we will
use on the \proglang{R} side. It usually makes sense to use the same name as the class
name, but this is not forced, which might be useful when exposing a class
generated from a template.

The construction of the object is then followed by two calls to the
\texttt{method} member function of \texttt{class\_<World>}. The
\texttt{method} methods can expose :
\begin{itemize}
\item member functions of the target class, such as \texttt{greet} or \texttt{set}, by
providing the name that will be used on the \proglang{R} side (e.g. \texttt{greet}) and
a pointer to the actual member function (e.g. \texttt{\&World::greet} )
\item free functions that take a pointer to the target class as their
first parameter such as the \proglang{C++} function \texttt{clearWorld} in the previous
example. Again, we provide the \proglang{R} name for the method (\texttt{clear}) and
a pointer to the \proglang{C++} function.
\end{itemize}

The module exposes the default constructor of the \texttt{World} class as
well to support creation of \texttt{World} objects from \proglang{R}. The
\pkg{Rcpp} module assumes responsibilities for type conversion for input and
output types.

<<eval=FALSE>>=
require( Rcpp )

# load the module
yada <- Module( "yada" )

# grab the World class
World <- yada$World

# create a new World object
w <- new( World )

# use methods of the class
w$greet()
w$set( "hello world" )
w$greet()
w$clear()
w$greet()
@

\subsubsection{Const and non-const member functions}

\texttt{method} is able to expose both \texttt{const} and \texttt{non const}
member functions of a class. There are however situations where
a class defines two versions of the same method, differing only in their
signature by the \texttt{const}-ness. It is for example the case of the
member functions \texttt{back} of the \texttt{std::vector} template from
the STL.

<<lang=cpp>>=
reference back ( );
const_reference back ( ) const;
@

To resolve the ambiguity, it is possible to use \texttt{const\_method}
or \texttt{nonconst\_method} instead of \texttt{method} in order
to restrict the candidate methods.

\subsubsection{S4 dispatch}

When a \proglang{C++} class is exposed by the \texttt{class\_} template,
a new S4 class is registered as well. The name of the S4 class is
obfuscated in order to avoid name clashes (i.e. two modules exposing the
same class).

This allows implementation of \proglang{R}-level
(S4) dispatch. For example, one might implement the \texttt{show}
method for \proglang{C++} \texttt{World} objects:

<<eval=FALSE>>=
setMethod( "show", yada$World , function(object){
	msg <- paste( "World object with message : ", object$greet() )
	writeLines( msg )
} )
@

\subsubsection{Special methods}

\pkg{Rcpp} considers the methods \texttt{[[} and \texttt{[[<-} special,
and promotes them to indexing methods on the \proglang{R} side.

\subsubsection{Exposing public data members}

Public data members of a \proglang{C++} class can be exposed by
\texttt{field} or \texttt{field\_readonly}.

<<lang=cpp>>=
	class Num{
	public:
	    Num() : x(0.0), y(0){} ;

	    double x ;
	    int y ;
	};

	RCPP_MODULE(yada){
		using namespace Rcpp ;

		class_<Num>( "Num" )

			// read and write data member
			.field( "x", &Num::x )

			// read only data member
			.field_readonly( "y", &Num::y )
		;
	}
@

Here, the class \texttt{Num} exposes the data member \texttt{x}
with read/write access, and the data member \texttt{y} with only
read access.

\subsubsection{Properties}

Properties provides a more general way to expose data members,
through the explicit registration of getter and setter. Properties
are declared by the \texttt{property} method of \texttt{class\_}.

<<lang=cpp>>=
class Num{
public:
    Num() : x(0.0), y(0){} ;

    double getX() { return x ; }
    void setX(double value){ x = value ; }

    int getY() { return y ; }

private:
    double x ;
    int y ;
};

RCPP_MODULE(yada){
	using namespace Rcpp ;

	class_<Num>( "Num" )

		// read and write property
		.property( "x", &Num::getX, &Num::setX )

		// read-only property
		.property( "y", &Num::getY )
	;
}
@

The \texttt{x} property is declared with both getter (\texttt{getX}) and
setter (\texttt{setX}) so that we can read and write the property at the R level
with the dollar operator.

The \texttt{y} property only exposes a getter (\texttt{getY}) so attempting to
set the property from R will generate an error.

<<eval=FALSE>>=
mod <- Module( "yada" )
Num <- mod$Num
w <- new( Num )
w$x
# [1] 0
w$x <- 2.0
w$x
# [1] 2
w$y
# [1] 0
# y is read-only, this generates an error
w$y <- 10L
@

Getters may be const or non-const member functions of the target class taking
no parameters. Free functions taking a pointer to the target class are also
allowed as getters.

Setters can be non-const member function taking one parameter or a free
function taking a pointer to target class as the first parameter, and the new
value as the second parameter.

\subsubsection{Full example}

The following example illustrates how to use Rcpp modules to expose
the class \texttt{std::vector<double>} from the STL.

<<lang=cpp>>=
// convenience typedef
typedef std::vector<double> vec ;

// helpers
void vec_assign( vec* obj, Rcpp::NumericVector data ){
	obj->assign( data.begin(), data.end() ) ;
}

void vec_insert( vec* obj, int position, Rcpp::NumericVector data){
	vec::iterator it = obj->begin() + position ;
	obj->insert( it, data.begin(), data.end() ) ;
}

Rcpp::NumericVector vec_asR( vec* obj ){
	return Rcpp::wrap( *obj ) ;
}

void vec_set( vec* obj, int i, double value ){
	obj->at( i ) = value ;
}

RCPP_MODULE(yada){
    using namespace Rcpp ;

    // we expose the class std::vector<double> as "vec" on the R side
    class_<vec>( "vec")

    // exposing member functions
    .method( "size", &vec::size)
    .method( "max_size", &vec::max_size)
    .method( "resize", &vec::resize)
    .method( "capacity", &vec::capacity)
    .method( "empty", &vec::empty)
    .method( "reserve", &vec::reserve)
    .method( "push_back", &vec::push_back )
    .method( "pop_back", &vec::pop_back )
    .method( "clear", &vec::clear )

    // specifically exposing const member functions
    .const_method( "back", &vec::back )
    .const_method( "front", &vec::front )
    .const_method( "at", &vec::at )

    // exposing free functions taking a std::vector<double>*
    // as their first argument
    .method( "assign", &vec_assign )
    .method( "insert", &vec_insert )
    .method( "as.vector", &vec_asR )

    // special methods for indexing
    .const_method( "[[", &vec::at )
    .method( "[[<-", &vec_set )

	;
}
@

\section{Using modules in other packages}

\subsection{Namespace import/export}

When using \pkg{Rcpp} modules in a packages, the client package needs to
import a set of classes from \pkg{Rcpp}. This is achieved by adding the
following line to the \texttt{NAMESPACE} file.

<<echo=FALSE,eval=TRUE>>=
options( prompt = " ", continue = " " )
@

<<eval=FALSE>>=
importClassesFrom( Rcpp, "C++Object", "C++Class", "Module" )
@

Loading modules that are defined in a package is best placed inside the
\Sexpr{link(".onLoad" )} hook for the package.

<<eval=FALSE>>=
NAMESPACE <- environment()
# this will be replaced by the real module
yada <- new( "Module" )

.onLoad <- function(libname, pkgname){
	# load the module and store it in our namespace
	unlockBinding( "yada" , NAMESPACE )
	assign( "yada",  Module( "yada" ), NAMESPACE )
	lockBinding( "yada", NAMESPACE )
}
@

<<echo=FALSE,eval=TRUE>>=
options( prompt = "> ", continue = "+ " )
@

\subsection{Support for modules in skeleton generator}

The \Sexpr{link("Rcpp.package.skeleton")} function has been improved to help
\pkg{Rcpp} modules. When the \texttt{module} argument is set to \texttt{TRUE},
the skeleton generator installs code that uses a simple module.

<<eval=FALSE>>=
Rcpp.package.skeleton( "testmod", module = TRUE )
@

\subsection{Module documentation}

\pkg{Rcpp} defines a \Sexpr{link("prompt")} method for the
\Sexpr{linkS4class("Module")} class, allowing generation of a skeleton of an Rd
file containing some information about the module.

<<eval=FALSE>>=
yada <- Module( "yada" )
prompt( yada, "yada-module.Rd" )
@

\section{Future extensions}

\texttt{Boost.Python} has many more features that we would like to port
to Rcpp modules : class inheritance, overloading, default arguments, enum
types, ...

\section{Summary}

This note introduced \textsl{Rcpp modules} and illustrated how to expose
\proglang{C++} function and classes more easily to \proglang{R}.
\textsl{Rcpp modules} is a relatively new addition to the \pkg{Rcpp} package
and will probably undergo a few more changes. We hope that \proglang{R} and
\proglang{C++} programmers find \textsl{Rcpp modules} useful.

\bibliographystyle{plainnat}
\bibliography{Rcpp}

\end{document}

