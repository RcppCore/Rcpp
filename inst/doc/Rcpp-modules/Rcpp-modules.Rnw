\documentclass[10pt]{article}
%\VignetteIndexEntry{Rcpp-modules}
\usepackage{vmargin}
\usepackage{color}
\usepackage{alltt}
\usepackage[authoryear,round,longnamesfirst]{natbib}

\usepackage[colorlinks]{hyperref}
\setmargrb{0.75in}{0.75in}{0.75in}{0.75in}
\newcommand{\proglang}[1]{\textsf{#1}}
\newcommand{\pkg}[1]{{\fontseries{b}\selectfont #1}}

\author{Dirk Eddelbuettel \and Romain Fran\c{c}ois}
\title{Exposing \proglang{C++} functions and classes with Rcpp modules}

<<echo=FALSE>>=
link <- function( f, package, text = f, root = "http://finzi.psych.upenn.edu/R/library/" ){
	h <- if( missing(package) ) {
		as.character( help( f ) )
	} else {
		as.character( help( f, package = paste( package, sep = "" ) ) )
	}
	if( ! length(h) ){
		sprintf( "\\\\textbf{%s}", f )
	} else {
		rx <- "^.*/([^/]*?)/help/(.*?)$"
		package <- sub( rx, "\\1", h, perl = TRUE )
		page <- sub( rx, "\\2", h, perl = TRUE )
		sprintf( "\\\\href{%s%s/html/%s.html}{\\\\texttt{%s}}", root, package, page, text )
	}
}
linkS4class <- function( cl, package, text = cl, root = "http://finzi.psych.upenn.edu/R/library/" ){
	link( sprintf("%s-class", cl), package, text, root )
}
@

\begin{document}
\maketitle

\abstract{
  \noindent
  This note discusses \textsl{Rcpp modules} which have been introduced in version 0.8.1 of \pkg{Rcpp}.
  \textsl{Rcpp modules} allow programmers to more easily expose \proglang{C++} functions and classes to \proglang{R}.
  \textsl{Rcpp modules} are inspired from the \texttt{Boost.Python} \citep{Boost:Python}
  \proglang{C++} library which provides the same features (and much more) for
  Python. This document is a short overview of the capabilities of modules.
}

\section{Motivation}

Exposing \proglang{C++} functionality to \proglang{R} is greatly facilitated by the \pkg{Rcpp}
package and underlying \proglang{C++} library \citep{CRAN:Rcpp}. \pkg{Rcpp}
facilitates \proglang{R} and \proglang{C++} integration by replacing use of the traditionnal \proglang{R} API
by a consistent set of \proglang{C++} classes.

However, these facilities are limited to a function by function basis. The
programmer has to implement a \Sexpr{link(".Call")} compatible function
using classes of the \pkg{Rcpp} API.

\subsection{Exposing functions}

Exposing existing \proglang{C++} functions to \proglang{R} through \pkg{Rcpp}
usually involves writing an additional wrapper function that is responsible
for converting input objects to the appropriate types, calling the function
and converting the results back to a suitable type that can be returned to
R. This return type may be the traditionnal \texttt{SEXP} from the \proglang{R} API, or any type from the
\pkg{Rcpp} API that offers implicit conversion to \texttt{SEXP} (many of them do).

Consider the \texttt{hello} function below:

<<lang=cpp>>=
const char* hello( std::string who ){
	std::string result( "hello " ) ;
	result += who ;
	return result.c_str() ;
}
@

One can expose a such a function using \pkg{Rcpp} converters

<<lang=cpp>>=
RcppExport SEXP hello_wrapper( SEXP who){
    std::string input = Rcpp::as<std::string>( who )
    const char* result = hello( input ) ;
    return Rcpp::wrap( result );
}
@

Or more traditionally using the \proglang{R} API :

<<lang=cpp>>=
extern "C" SEXP hello_wrapper( SEXP who){
    std::string input = CHAR(STRING_ELT(input,0)) ;
    const char* result = hello( input ) ;
    return mkString( result );
}
@

Either way requires direct involvement from the programmer. This quickly
becomes a time sink when many functions are involved. \textsl{Rcpp modules}
provides a much more efficient way to expose the \texttt{hello} function to \proglang{R}.

\subsection{Exposing classes}

Exposing \proglang{C++} classes or structs is even more of a challenge because it
requires writing glue code for each member function that is to be exposed. Consider the
simple \texttt{World} class below:

<<lang=cpp>>=
class World {
public:
    World() : msg("hello"){}
    void set(std::string msg) { this->msg = msg; }
    std::string greet() { return msg; }

private:
    std::string msg;
};
@

We might want a way to create objects of this class, and use the member
functions \texttt{greet} and \texttt{set} to alter the object. External pointers
\citep{R:exts} are the perfect vessel for this, and using the
\texttt{Rcpp:::XPtr} template from \pkg{Rcpp} we can expose the class
by exposing three functions :

<<lang=cpp>>=
using namespace Rcpp ;

/** create an external pointer to a World object */
RcppExport SEXP World__new(){
	return Rcpp::XPtr<World>( new World, true ) ;
}

/** invoke the greet method */
RcppExport SEXP World__greet( SEXP xp ) {
	Rcpp::XPtr<World> w(xp) ;
	return Rcpp::wrap( w->greet() ) ;
}

/** invoke the set method */
RcppExport SEXP World__set( SEXP xp, SEXP msg ){
	Rcpp::XPtr<World> w(xp) ;
	w->set( Rcpp::as<std::string>( msg ) ) ;
	return R_NilValue ;
}
@

which can be used from \proglang{R} with some S4 glue code:

<<eval=FALSE>>=
setClass( "World", representation( pointer = "externalptr" ) )

World_method <- function(name){
	paste( "World", name, sep = "__" )
}

setMethod( "$", "World", function(x, name ){
	function(...) .Call( World_method(name) , x@pointer, ... )
} )

w <- new( "World", .Call( World_method( "new" ) ) )
w$set( "hello world" )
w$greet()
@

\pkg{Rcpp} considerably simplifies the code that would be involved for using
external pointers with the traditional \proglang{R} API. This still involves
a lot of pattern code that quickly becomes hard to maintain and error prone.
\textsl{Rcpp modules} offer a much nicer way to expose the \texttt{World}
class in a way that makes both the internal \proglang{C++} code and the \proglang{R} code easier.

\section{Rcpp modules}

Rcpp modules are inspired from Python modules that are generated
by the \texttt{Boost.Python} library. They provide an easy way to expose
\proglang{C++} functions and classes to \proglang{R}, grouped together in a single entity.

The module is created in a cpp file using the \texttt{RCPP\_MODULE}
macro, which then contains declarative code of what the module
exposes to \proglang{R}.

\subsection{Exposing \proglang{C++} functions}

Consider the \texttt{hello} function from the previous section.
We can expose it to \proglang{R} :

<<lang=cpp>>=
const char* hello( std::string who ){
	std::string result( "hello " ) ;
	result += who ;
	return result.c_str() ;
}

RCPP_MODULE(yada){
	using namespace Rcpp ;
	function( "hello", &hello ) ;
}
@

The code creates an Rcpp module called \texttt{yada}
that exposes the \texttt{hello} function. \pkg{Rcpp} automatically
deduces the conversions that are needed for input and output.

On the \proglang{R} side, the module is simply retrieved by using the \Sexpr{link("Module")}
function from \pkg{Rcpp}:

<<eval=FALSE>>=
require( Rcpp )
yada <- Module( "yada" )
yada$hello( "world" )
@

A module can contain any number of calls to \texttt{function} to register
many internal functions to \proglang{R}. For example, these 6 functions :

<<lang=cpp>>=
std::string hello(){
	return "hello" ;
}

int bar( int x){
	return x*2 ;
}

double foo( int x, double y){
	return x * y ;
}

void bla( ){
	Rprintf( "hello\\n" ) ;
}

void bla1( int x){
	Rprintf( "hello (x = %d)\\n", x ) ;
}

void bla2( int x, double y){
	Rprintf( "hello (x = %d, y = %5.2f)\\n", x, y ) ;
}
@

can be exposed with the following minimal code:

<<lang=cpp>>=
RCPP_MODULE(yada){
	using namespace Rcpp ;

	function( "hello" , &hello ) ;
	function( "bar"   , &bar   ) ;
	function( "foo"   , &foo   ) ;
	function( "bla"   , &bla   ) ;
	function( "bla1"  , &bla1   ) ;
	function( "bla2"  , &bla2   ) ;
}
@

and used from \proglang{R}:

<<eval=FALSE>>=
require( Rcpp )

yada <- Module( "yada" )
yada$bar( 2L )
yada$foo( 2L, 10.0 )
yada$hello()
yada$bla()
yada$bla1( 2L)
yada$bla2( 2L, 5.0 )
@

The requirements on the functions to be exposed are:
\begin{itemize}
\item It takes between 0 and 65 parameters.
\item The type of each input parameter must be manageable by the \texttt{Rcpp::as}
template.
\item The output type must be either \texttt{void} or any type that
can be managed by the \texttt{Rcpp::wrap} template.
\item The function name itself has to be unique, in other words no two functions with
  the same name but different signatures (as in \proglang{C++} itself) are allowed.
\end{itemize}

\subsection{Exposing \proglang{C++} classes}

Rcpp modules also provide a mechanism for exposing \proglang{C++} classes. The mechanism
internally uses external pointers, but the user should consider this as
hidden implementation details as this is properly encapsulated.

A class is exposed using the \texttt{class\_} class. The \texttt{World}
class may be exposed to \proglang{R} :

<<lang=cpp>>=
class World {
public:
    World() : msg("hello"){}
    void set(std::string msg) { this->msg = msg; }
    std::string greet() { return msg; }

private:
    std::string msg;
};

void clearWorld( World* w){
	w->set( "" ) ;
}

RCPP_MODULE(yada){
	using namespace Rcpp ;

	class_<World>( "World" )
		.method( "greet", &World::greet )
		.method( "set", &World::set )
		.method( "clear", &clearWorld )
	;

}
@

\texttt{class\_} is templated by the \proglang{C++} class or struct that is to be exposed
to \proglang{R}. The parameter of the \texttt{class\_<World>} constructor is the name we will
use on the \proglang{R} side. It usually makes sense to use the same name as the class
name, but this is not forced, which might be useful when exposing a class
generated from a template.

The construction of the object is then followed by two calls to the
\texttt{method} member function of \texttt{class\_<World>}. \texttt{method}
can expose :
\begin{itemize}
\item member functions of the target class, such as \texttt{greet} or \texttt{set}, by
providing the name that will be used on the \proglang{R} side (e.g. \texttt{greet}) and
a pointer to the actual member function (e.g. \texttt{\&World::greet} )
\item free funtions that take a pointer to the target class as their
first parameter such as the \proglang{C++} function \texttt{clearWorld} in the previous
example. Again, we provide the \proglang{R} name for the method (\texttt{clear}) and
a pointer to the \proglang{C++} function.
\end{itemize}

The module exposes the default constructor of the \texttt{World} class as well
to support creation of \texttt{World} objects from \proglang{R}. The Rcpp module assumes
responsabilities for type conversion for input and output types.

<<eval=FALSE>>=
require( Rcpp )

# load the module
yada <- Module( "yada" )

# grab the World class
World <- yada$World

# create a new World object
w <- new( World )

# use methods of the class
w$greet()
w$set( "hello world" )
w$greet()
w$clear()
w$greet()
@

\subsubsection{Const and non-const member functions}

\texttt{method} is able to expose both \texttt{const} and \texttt{non const}
member functions of a class. There are however situations where
a class defines two versions of the same method, differing only in their
signature by the \texttt{const}-ness. It is for example the case of the
member functions \texttt{back} of the \texttt{std::vector} template from
the STL.

<<lang=cpp>>=
reference back ( );
const_reference back ( ) const;
@

To resolve the ambiguity, it is possible to use \texttt{const\_method}
or \texttt{nonconst\_method} instead of \texttt{method} in order
to restrict the candidate methods.

\subsubsection{S4 dispatch}

When a \proglang{C++} class is exposed by the \texttt{class\_} template,
a new S4 class is registered as well. This allows implementation of \proglang{R}-level
(S4) dispatch. For example, one might implement the \texttt{show}
method for \proglang{C++} \texttt{World} objects:

<<eval=FALSE>>=
setMethod( "show", "World", function(object){
	msg <- paste( "World object with message : ", object$greet() )
	writeLines( msg )
} )
@

\subsubsection{Special methods}

\pkg{Rcpp} considers the methods \texttt{[[} and \texttt{[[<-} special,
and promotes them to indexing methods on the \proglang{R} side.

\subsubsection{Full example}

The following example illustrates how to use Rcpp modules to expose
the class \texttt{std::vector<double>} from the STL.

<<lang=cpp>>=
// convenience typedef
typedef std::vector<double> vec ;

// helpers
void vec_assign( vec* obj, Rcpp::NumericVector data ){
	obj->assign( data.begin(), data.end() ) ;
}

void vec_insert( vec* obj, int position, Rcpp::NumericVector data){
	vec::iterator it = obj->begin() + position ;
	obj->insert( it, data.begin(), data.end() ) ;
}

Rcpp::NumericVector vec_asR( vec* obj ){
	return Rcpp::wrap( *obj ) ;
}

void vec_set( vec* obj, int i, double value ){
	obj->at( i ) = value ;
}

RCPP_MODULE(yada){
	using namespace Rcpp ;

	// we expose the class std::vector<double> as "vec" on the R side
	class_<vec>( "vec")

		// exposing member functions
	 	.method( "size", &vec::size)
 		.method( "max_size", &vec::max_size)
 		.method( "resize", &vec::resize)
 		.method( "capacity", &vec::capacity)
 		.method( "empty", &vec::empty)
 		.method( "reserve", &vec::reserve)
 		.method( "push_back", &vec::push_back )
 		.method( "pop_back", &vec::pop_back )
 		.method( "clear", &vec::clear )

 		// specifically exposing const member functions
 		.const_method( "back", &vec::back )
		.const_method( "front", &vec::front )
		.const_method( "at", &vec::at )

		// exposing free functions taking a std::vector<double>*
		// as their first argument
		.method( "assign", &vec_assign )
		.method( "insert", &vec_insert )
		.method( "as.vector", &vec_asR )

		// special methods for indexing
		.const_method( "[[", &vec::at )
		.method( "[[<-", &vec_set )

	;
}
@

\section{Using modules in other packages}

\subsection{Namespace import/export}

When using \pkg{Rcpp} modules in a packages, the client package needs to
import a set of classes from \pkg{Rcpp}. This is achieved by adding the
following line to the \texttt{NAMESPACE} file.

<<echo=FALSE,eval=TRUE>>=
options( prompt = " ", continue = " " )
@

<<eval=FALSE>>=
importClassesFrom( Rcpp, "C++ObjectS3", "C++Object", "C++Class", "Module" )
@

Loading modules that are defined in a package is best placed inside the
\Sexpr{link(".onLoad" )} hook for the package.

<<eval=FALSE>>=
NAMESPACE <- environment()
# this will be replaced by the real module
yada <- new( "Module" )

.onLoad <- function(libname, pkgname){
	# load the module and store it in our namespace
	unlockBinding( "yada" , NAMESPACE )
	assign( "yada",  Module( "yada" ), NAMESPACE )
	lockBinding( "yada", NAMESPACE )
}
@

<<echo=FALSE,eval=TRUE>>=
options( prompt = "> ", continue = "+ " )
@

\subsection{Support for modules in skeleton generator}

The \Sexpr{link("Rcpp.package.skeleton")} function has been improved to help
\pkg{Rcpp} modules. When the \texttt{module} argument is set to \texttt{TRUE},
the skeleton generator installs code that uses a simple module.

<<eval=FALSE>>=
Rcpp.package.skeleton( "testmod", module = TRUE )
@

\subsection{Module documentation}

\pkg{Rcpp} defines a \Sexpr{link("prompt")} method for the
\Sexpr{linkS4class("Module")} class, allowing generation of a skeleton of an Rd
file containing some information about the module.

<<eval=FALSE>>=
yada <- Module( "yada" )
prompt( yada, "yada-module.Rd" )
@

\section{Future extensions}

\texttt{Boost.Python} has many more features that we would like to port
to Rcpp modules : class inheritance, overloading, default arguments, enum
types, ...

\section{References}

\bibliographystyle{abbrvnat}
\bibliography{Rcpp-modules}

\end{document}

