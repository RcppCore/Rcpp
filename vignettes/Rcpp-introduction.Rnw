\documentclass[9pt,twocolumn,twoside]{rcpp-docs}  % no lineno
%% rcpp-docs is a local class derived from the PNAS offered by 
%% Overleaf and the Proceedings of the National Academy of Science
%% See http://www.pnas.org/site/authors/latex.xhtml

%\VignetteIndexEntry{Rcpp-introduction}
%\VignetteKeywords{Rcpp,RcppArmadillo,C++,R}
%\VignettePackage{Rcpp}


\title{Extending \rlang with C++:\\ A Brief Introduction to Rcpp}

\author[a]{Dirk Eddelbuettel}
\author[b]{James Joseph Balamuta} 

\affil[a]{Debian and R Projects}
\affil[b]{Departments of Informatics and Statistics, University of Illinois at Urbana-Champaign}

\leadauthor{Eddelbuettel \& Balamuta} 

\keywords{applications and case studies $|$ statistical computing $|$ computationally
intensive methods $|$ simulation}

\begin{abstract}
\rlang has always provided an application programming interface (API)
for extensions. Based on the \clang language, it uses a number of macros
and other low-level constructs to exchange data structures between the
\rlang process and any dynamically-loaded component modules authors
added to it. With the introduction of the \rcpp package, and its later
refinements, this process has become considerably easier yet also more
robust. By now, \rcpp has become the most popular extension mechanism
for \rlangns. This article introduces \rcppns, and illustrates with
several examples how the \emph{Rcpp Attributes} mechanism in particular
eases the transition of objects between \rlang and \cpp code.
\end{abstract}

\dates{This manuscript was compiled on \today}
\doi{\url{http://cran.r-project.org/package=Rcpp}}

\begin{document}

\SweaveOpts{engine=R,eps=FALSE,echo=FALSE,prefix.string=figures/chart}

\setkeys{Gin}{width=0.8\textwidth}

% Optional adjustment to line up main text (after abstract) of first page with line numbers, when using both lineno and twocolumn options.
% You should only change this length when you've finalised the article contents.
%\verticaladjustment{-2pt}

\maketitle
\thispagestyle{firststyle}
\ifthenelse{\boolean{shortarticle}}{\ifthenelse{\boolean{singlecolumn}}{\abscontentformatted}{\abscontent}}{}


\section{Introduction}\label{introduction}

The \rlang language and environment \citep{R:Main} has established itself as
both an increasingly dominant facility for data analysis, and the
\emph{lingua franca} for statistical computing in both research and
application settings.

Since the beginning, and as we argue below, ``by design'', the
\rlang system has always provided an application programming interface
(API) suitable for extending \rlang with code written in \clang or
\fortranns. Being implemented chiefly in \rlang and \clang (with a
generous sprinkling of \fortran
for well-established numerical subroutines), \rlang has always been
extensible via a \clang interface. Both the actual implementation and
the \clang interface use a number of macros and other low-level
constructs to exchange data structures between the \rlang process and
any dynamically-loaded component modules authors added to it.

A \clang interface will generally also be accessible to other languages.
Particularly noteworthy here is the \cpp language, developed originally
as a `better \clangns', which is by its design very interoperable with
\clangns. And with the introduction of the \rcpp package
\citep{JSS:Rcpp,Eddelbuettel:2013:Rcpp,CRAN:Rcpp}, and its later refinements, this
process of extending \rlang has become considerably easier yet also more
robust. To date, \rcpp has become the most popular extension system for
\rlangns. This article introduces \rcppns, and illustrates with several
examples how the \emph{Rcpp Attributes} mechanism
\citep{CRAN:Rcpp:Attributes} in particular eases the transition of
objects between \rlang and \cpp code.

\subsection{Background}\label{background}

\citet[p. 3]{Chambers:2008:SoDA} provides a very thorough discussion of
desirable traits for a system designed to \emph{program with data}, and
the \rlang system in particular. Two key themes motivate the
introductory discussion. First, the \emph{Mission} is to aid exploration
in order to provide the best platform to analyse data: ``to boldly go
where no one has gone before.'' Second, the \emph{Prime Directive} is
that the software systems we build must be \emph{trustworthy}: ``the
many computational steps between original data source and displayed
result must all be trustful.'' The remainder of the book then discusses
\rlangns, leading to two final chapters on interfaces.

\citet[p. 4]{Chambers:2016:ExtR} builds and expands on this theme. Two
core facets of what ``makes'' \rlang are carried over from the previous
book. The first states what \rlang is composed of: \emph{Everything that
exists in \rlang is an object}. The second states how these objects are
created or altered: \emph{Everything that happens in \rlang is a
function call}. A third statement is now added: \emph{Interfaces to
other software are part of \rlangns}.

This last addition is profound. If and when suitable and performant
software for a task exists, it is in fact desirable to have a
(preferably also perfomant) interface to this software from \rlangns.
\cite{Chambers:2016:ExtR} discusses several possible approaches for
simpler interfaces and illustrates them with reference implementations
to both \python~and \julia. However, the most performant interface for
\rlang is provided at the subroutine level, and rather than discussing
the older \clang interface for \rlangns, \cite{Chambers:2016:ExtR}
prefers to discuss \rcppns. This article follows the same school of
thought and aims to introduce \rcpp to analysts and data scientists,
aiming to enable them to use---and create--- further \emph{interfaces}
for \rlang which aid the \emph{mission} while staying true to the
\emph{prime directive}. Adding interfaces in such a way is in fact a
natural progression from the earliest designs for its predecessor
\slang which was after all designed to provide a more useable
`interface' to underlying routines in \fortranns.

The rest of the paper is structured as follows. We start by discussing
possible first steps, chiefly to validate correct installations. This is
followed by an introduction to simple \cpp functions, comparison to the
\clang API, a discussion of packaging with \rcpp and a linear algebra
example. The appendix contains some empirical illustrations of the
adoption of \rcppns.

\section{\texorpdfstring{First Steps with
\rcpp}{First Steps with }}\label{first-steps-with}

\rcpp is a CRAN package and can be installed by using
\texttt{install.packages(\textquotesingle{}Rcpp\textquotesingle{})} just
like any other \rlang package. On some operating systems this will
download \emph{pre-compiled} binary packages; on others an installation
from source will be attempted. But \rcpp is a little different from many
standard \rlang packages in one important aspect: it helps the user to
\emph{write C(++) programs more easily}. The key aspect to note here is
\cpp
programs: to operate, \rcpp needs not only \rlang but also an additional
\emph{toolchain} of a compiler, linker and more in order to be able to
create \emph{binary} object code extending \rlangns.

We note that this requirement is no different from what is needed with
base \rlang when compilation of extensions is attempted. How to achieve
this using only base \rlang is described in some detail in the
\emph{Writing R Extensions} manual \citep{R:Extensions} that is included
with \rlangns. As for the toolchain requirements, on Linux and macOS,
all required components are likely to be present. The macOS can offer
additional challenges as toolchain elements can be obtained in different
ways. Some of these are addressed in the \emph{Rcpp FAQ}
\citep{CRAN:Rcpp:FAQ} in sections 2.10 and 2.16. On Windows, users will
have to install the Rtools kit provided by R Core available at
\url{https://cran.r-project.org/bin/windows/Rtools/}. Details of these
installation steps are beyond the scope of this paper. However, many
external resources exist that provide detailed installation guides for
\rlang toolschains in
\href{http://thecoatlessprofessor.com/programming/rcpp/install-rtools-for-rcpp/}{Windows}
and
\href{http://thecoatlessprofessor.com/programming/r-compiler-tools-for-rcpp-on-os-x/}{macOS}.

As a first step, and chiefly to establish that the toolchain is set up
correctly, consider a minimal use case such as the following:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"Rcpp"}\NormalTok{)}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"2 + 2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}



\begin{verbatim}
## [1] 4
\end{verbatim}

Here the \rcpp package is loaded first via the \texttt{library()}
function. Next, we deploy one of its simplest functions,
\texttt{evalCpp()}, which is described in the \emph{Rcpp Attributes}
vignette \citep{CRAN:Rcpp:Attributes}. It takes the first (and often
only) argument---a character object---and evaluates it as a minimal
\cpp expression. The value assignment and return are implicit, as is the
addition of a trailing semicolon and more. In fact, \texttt{evalCpp()}
surrounds the expression with the required `glue' to make it a minimal
source file which can be compiled, linked and loaded. The exact details
behind this process are available in-depth when the \texttt{verbose}
option of the function is set. If everything is set up correctly, the
newly-created \rlang function will be returned.

While such a simple expression is not interesting in itself, it serves a
useful purpose here to unequivocally establish whether \rcpp is
correctly set up. Having accompishled that, we can proceed to the next
step of creating simple functions.

\section{\texorpdfstring{A first \cpp function using
\rcpp}{A first function using }}\label{a-first-function-using}

As a first example, consider the determination of whether a number is
odd or even. The default practice is to use modular arithmetic to check
if a remainder exists under \(x \bmod 2\). Within \rlangns, this can be
implemented as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{isOddR <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{num =}\NormalTok{ 10L) \{}
\NormalTok{   result <-}\StringTok{ }\NormalTok{(num }\OperatorTok{%%}\StringTok{ }\NormalTok{2L }\OperatorTok{==}\StringTok{ }\NormalTok{1L)}
   \KeywordTok{return}\NormalTok{(result)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The operator \texttt{\%\%} implements the \(\bmod\) operation in
\rlangns. For the default (integer) argument of ten used in the example,
\(10 \bmod 2\) results in zero, which is then mapped to \texttt{FALSE}
in the context of a logical expression.

Translating this implementation into \cppns, several small details have
to be considered. First and foremost, as \cpp is a
\emph{statically-typed language}, there needs to be additional
(compile-time) information provided for each of the variables.
Specifically, a \emph{type}, \emph{i.e.} the kind of storage used by a
variable must be explicitly defined. Typed languages generally offer
benefits in terms of both correctness (as it is harder to accidentally
assign to an ill-matched type) and performance (as the compiler can
optimize code based on the storage and cpu characteristics). Here we
have an \texttt{int} argument, but return a logical, or \texttt{bool}
for short. Two more smaller differences are that each statement within
the body must be concluded with a semicolon, and that \texttt{return}
does not require parentheses around its argument. A graphical breakdown
of all aspects of a corresponding \cpp function is given in Figure
\ref{fig:cpp-function-annotation}.

\begin{figure*}
  \begin{center}
     \includegraphics[width=0.9\textwidth]{figures/function_annotation_cpp} 
     \caption{\label{fig:cpp-function-annotation}
       Graphical annotation of the \texttt{isOddCpp} function.}
     \label{fig:cpp_annotated}
  \end{center}
\end{figure*}

When using \rcppns, such \cpp functions can be directly embedded and
compiled in an \rlang
script file through the use of the \texttt{cppFunction()} provided by
\emph{Rcpp Attributes} \citep{CRAN:Rcpp:Attributes}. The first parameter
of the function accepts string input that represents the \cpp code. Upon
calling the \texttt{cppFunction()}, and similarly to the earlier example
involving \texttt{evalCpp()}, the \cpp code is both \emph{compiled} and
\emph{linked}, and then \emph{imported} into \rlang under the name of
the function supplied (\emph{e.g.} here \texttt{isOddCpp()}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"Rcpp"}\NormalTok{)}
\KeywordTok{cppFunction}\NormalTok{(}\StringTok{"}
\StringTok{bool isOddCpp(int num = 10) \{}
\StringTok{   bool result = (num % 2 == 1);}
\StringTok{   return result;}
\StringTok{\}"}\NormalTok{)}
\KeywordTok{isOddCpp}\NormalTok{(42L)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\section{\texorpdfstring{Extending \rlang via its
\clang API}{Extending via its API}}\label{extending-via-its-api}

Let us first consider the case of `standard \rlangns', \emph{i.e.} the
API as defined in the core \rlang documentation. Extending \rlang with
routines written using the \clang language requires the use of internal
macros and functions documented in Chapter 5 of \emph{Writing R
Extensions} \citep{R:Extensions}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<R.h>}
\PreprocessorTok{#include }\ImportTok{<Rinternals.h>}

\NormalTok{SEXP convolve2(SEXP a, SEXP b) \{}
   \DataTypeTok{int}\NormalTok{ na, nb, nab;}
   \DataTypeTok{double}\NormalTok{ *xa, *xb, *xab;}
\NormalTok{   SEXP ab;}

\NormalTok{   a = PROTECT(coerceVector(a, REALSXP));}
\NormalTok{   b = PROTECT(coerceVector(b, REALSXP));}
\NormalTok{   na = length(a); nb = length(b); nab = na + nb - }\DecValTok{1}\NormalTok{;}
\NormalTok{   ab = PROTECT(allocVector(REALSXP, nab));}
\NormalTok{   xa = REAL(a); xb = REAL(b); xab = REAL(ab);}
   \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < nab; i++)}
\NormalTok{        xab[i] = }\FloatTok{0.0}\NormalTok{;}
   \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < na; i++)}
       \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ j = }\DecValTok{0}\NormalTok{; j < nb; j++)}
\NormalTok{           xab[i + j] += xa[i] * xb[j];}
\NormalTok{   UNPROTECT(}\DecValTok{3}\NormalTok{);}
   \ControlFlowTok{return}\NormalTok{ ab;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This function computes a \emph{convolution} of two vectors supplied on
input, \(a\) and \(b\), which is defined to be
\({ab_{k + 1}} = \sum\limits_{i - j == k} {{a_i} \cdot {b_j}}\). Before
computing the convolution (which is really just the three lines
involving two nested for loops with indices \(i\) and \(j\)), a total of
ten lines of mere housekeeping are required. Vectors \(a\) and \(b\) are
coerced to \texttt{double}, and a results vector \texttt{ab} is
allocated. This expression involves three calls to the \texttt{PROTECT}
macro for which a \emph{precisely} matching \texttt{UNPROTECT(3)} is
required as part of the interfacing of internal memory allocation. The
vectors are accessed through pointer equivalents \texttt{xa},
\texttt{xb} and \texttt{xab}; and the latter has to be explicitly zeroed
prior to the convolution calculation involving incremental summary at
index \(i+j\).

\section{\texorpdfstring{Extending \rlang via the \cpp API of
\rcpp}{Extending via the API of }}\label{extending-via-the-api-of}

Using the idioms of \rcppns, the above example can be written in a much
more compact fashion---leading to code that is simpler to read and
maintain.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{"Rcpp.h"}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{NumericVector convolve_cpp(}\AttributeTok{const}\NormalTok{ NumericVector& a,}
                           \AttributeTok{const}\NormalTok{ NumericVector& b) \{}
  
   \CommentTok{// Declare loop counters and vector sizes}
   \DataTypeTok{int}\NormalTok{ i, j,}
\NormalTok{       na = a.size(), nb = b.size(),}
\NormalTok{       nab = na + nb;}
    
   \CommentTok{// Create vector filled with 0}
\NormalTok{   NumericVector ab(nab);}
    
   \CommentTok{// Crux of the algorithm}
   \ControlFlowTok{for}\NormalTok{(i = }\DecValTok{0}\NormalTok{; i < na; i++) \{}
       \ControlFlowTok{for}\NormalTok{(j = }\DecValTok{0}\NormalTok{; j < nb; j++) \{}
\NormalTok{           ab[i + j] += a[i] * b[j];}
\NormalTok{       \}}
\NormalTok{   \}}
    
   \CommentTok{// Return result}
   \ControlFlowTok{return}\NormalTok{ ab;                                     }
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To deploy such code from within an \rlang script or session, first save
it into a new file---which could be called \textbf{convolve.cpp}---in
either the working directory, a temporary directoy or a project
directory. Then from within the \rlang session, use
\texttt{Rcpp::sourceCpp("convolve.cpp")} (possibly using a path as well
as the filename). This not only compiles, links and loads the code
within the external file but also adds the necessary ``glue'' to make
the \rcpp function available in the \rlang environment. Once the code is
compiled and linked, call the newly-created \texttt{convolveCpp()}
function with the appropriate parameters as done in previous examples.

What is notable about the \rcpp version is that it has no
\texttt{PROTECT} or \texttt{UNPROTECT} which not only frees the
programmer from a tedious (and error-prone) step but more importantly
also shows that memory management can be handled automatically. The
result vector is already initialized at zero as well, reducing the
entire function to just the three lines for the two nested loops, plus
some variable declarations and the \texttt{return} statement. The
resulting code is shorter, easier to read, comprehend and maintain.
Furthermore, the \rcpp code is more similar to traditional \rlang code,
which reduces the barrier of entry.

\section{\texorpdfstring{Data Driven Performance Decisions with
\rcpp}{Data Driven Performance Decisions with }}\label{data-driven-performance-decisions-with}

When beginning to implement an idea, more so an algorithm, there are
many ways one is able to correctly implement it. Prior to the routine
being used in production, two questions must be asked:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Does the implementation produce the \emph{correct} results?
\item
  What implementation of the routine is the \emph{best}?
\end{enumerate}

The first question is subject to a binary pass-fail unit test
verification while the latter question is where the details of an
implementation are scrutinized to extract maximal efficiency from the
routine. The quality of the \emph{best} routine follows first and
foremost from its correctness. To that end, \rlang offers many different
unit testing frameworks such as \pkg{RUnit} by \cite{CRAN:RUnit}, which
is used to construct \rcppns's 1385+ unit tests, and \pkg{testthat} by
\cite{CRAN:testthat}. Only when correctness is achieved is it wise to
begin the procedure of optimizing the efficiency of the routine and, in
turn, selecting the best routine.

Optimization of an algorithm involves performing a quantitative analysis
of the routine's properties. There are two main approaches to analyzing
the behavior of a routine: theoretical analysis\footnote{
Theoretical analysis is often directed to describing 
the limiting behavior of a function through asymptotic notation, 
commonly referred to as Big O and denoted as $\mathcal{O}(\cdot)$.} or
an empirical examination using profiling tools.\footnote{
Within base \rlangns, profiling can be activated by \code{utils::Rprof()}
for individual command timing information, \code{utils::Rprofmem()} for memory
information, and \code{System.time(\{\})} for a quick overall execution timing.
Additional profiling \rlang packages such as \pkg{profvis} by
\cite{CRAN:profvis}, \pkg{Rperform} by \cite{GitHub:Rperform}, and
benchmarking packages have extended the ability to analyze performance.}
Typically, the latter option is more prominently used as the routine's
theoretical properties are derived prior to an implementation being
started. Often the main concern regarding an implementation in
\rlang relates to the speed of the algorithm as it impacts how quickly
analyses can be done and reports can be provided to decision makers.
Coincidentally, the speed of code is one of the key governing use cases
of \rcppns. Profiling \rlang
code will reveal shortcomings related to loops, \emph{e.g.}
\texttt{for}, \texttt{while}, and \texttt{repeat}; conditional
statements, \emph{e.g.} \texttt{if}-\texttt{else\ if}-\texttt{else} and
\texttt{switch}; and recursive functions, \emph{i.e.} a function written
in terms of itself such that the problem is broken down on each call in
a reduced state until an answer can be obtained. In contrast, the
overhead for such operations is significantly less in \cppns. Thus,
critical components of a given routine should be written in \rcpp to
capture maximal efficiency.

Returning to the second question, to decide which implementation works
the best, one needs to employ a benchmark to obtain \emph{quantifiable
results}. Benchmarks are an ideal way to quantify how well a method
performs because they have the ability to show the amount of time the
code has been running and where bottlenecks exist within functions. This
does not imply that benchmarks are completely infallible as user error
can influence the end results. For example, if a user decides to
benchmark code in one \rlang session and in another session performs a
heavy computation, then the benchmark will be biased (if ``wall clock''
is measured).

There are different levels of magnification that a benchmark can
provide. For a more macro analysis, one should benchmark data using
\texttt{benchmark(test\ =\ func(),\ test2\ =\ func2())}, a function from
the \pkg{rbenchmark} \rlang package by \cite{CRAN:rbenchmark}. This form
of benchmarking will be used when the computation is more intensive. The
motivating example \texttt{isOdd()} (which is only able to accept a
single \texttt{integer}) warrants a much more microscopic timing
comparison. In cases such as this, the objective is to obtain precise
results in the amount of nanoseconds elapsed. Using the
\texttt{microbenchmark} function from the \pkg{microbenchmark}
\rlang package by \cite{CRAN:microbenchmark} is more helpful to obtain
timing information. To perform the benchmark:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"microbenchmark"}\NormalTok{)}

\NormalTok{results <-}\StringTok{ }\KeywordTok{microbenchmark}\NormalTok{(}\DataTypeTok{isOddR   =} \KeywordTok{isOddR}\NormalTok{(12L),}
                          \DataTypeTok{isOddCpp =} \KeywordTok{isOddCpp}\NormalTok{(12L))}
\NormalTok{results}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Unit: nanoseconds
##      expr min  lq  mean median   uq     max neval
##    isOddR 440 474 22104    509  549 2147598   100
##  isOddCpp 863 951 11312   1002 1080 1022464   100
\end{verbatim}

By looking at the summary of 100 evaluations, we note that the
\rcpp function performed better than the equivalent in \rlang by
achieving a lower run time on average. The lower run time in this part
is not necessarily critical as the difference is nanoseconds on a
trivial computation. However, each section of code does contribute to a
faster overall runtime.

\section{\texorpdfstring{Random Numbers within \rcpp: An Example of
\emph{Rcpp
Sugar}}{Random Numbers within : An Example of Rcpp Sugar}}\label{random-numbers-within-an-example-of-rcpp-sugar}

\rcpp connects \rlang with \cppns. Only the former is vectorized:
\cpp is not. \emph{Rcpp Sugar}, however, provides a convenient way to
work with high-performing \cpp functions in a similar way to how
\rlang offers vectorized operations. The \emph{Rcpp Sugar} vignette
\citep{CRAN:Rcpp:Sugar} details these, as well as many more functions
directly accessible to \rcpp in a way that should feel familiar to
\rlang users. Some examples of \emph{Rcpp Sugar} functions include
special math functions like gamma and beta, statistical distributions
and random number generation.

We will illustrate a case of random number generation. Consider drawing
one or more \(N(0,1)\)-distributed random variables. The very simplest
case can just use \texttt{evalCpp()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"R::rnorm(0, 1)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.2215613
\end{verbatim}

By setting a seed, we can make this reproducible:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{)}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"R::rnorm(0, 1)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.5604756
\end{verbatim}

One important aspect of the behind-the-scenes code generation for the
single expression (as well as all code created via \emph{Rcpp
Attributes}) is the automatic preservation of the state of the random
nunber generators in \rlangns. This means that from a given seed, we
will receive \emph{identical} draws of random numbers whether we access
them from \rlang or via \cpp code accessing the same generators (via the
\rcpp interfaces). To illustrate, the same number is drawn via
\rlang code after resetting the seed:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{)}
\CommentTok{# Implicit mean of 0, sd of 1}
\KeywordTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.5604756
\end{verbatim}

We can make the \emph{Rcpp Sugar} function \texttt{rnorm()} accessible
from \rlang in the same way to return a vector of values:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{)}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"Rcpp::rnorm(3)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.5604756 -0.2301775  1.5587083
\end{verbatim}

Note that we use the \texttt{Rcpp::} namespace explicitly here to
contrast the vectorised \texttt{Rcpp::rnorm()} with the scalar
\texttt{R::rnorm()} also provided as a convenience wrapper for the
\clang API of \rlangns.

And as expected, this too replicates from \rlang as the very same
generators are used in both cases along with consistent handling of
generator state permitting to alternate:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{)}
\KeywordTok{rnorm}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.5604756 -0.2301775  1.5587083
\end{verbatim}

\section{\texorpdfstring{Translating Code from \rlang into \rcpp: A
Bootstrapping
Example}{Translating Code from into : A Bootstrapping Example}}\label{translating-code-from-into-a-bootstrapping-example}

Statistical inference relied primarily upon asymptotic theory until
\cite{Efron:1979:Bootstrap} proposed the bootstrap. Bootstrapping is
known to be computationally intensive due to the need to use loops.
Thus, it is an ideal candidate to use as an example. Before starting to
write \cpp code using \rcpp, prototype the code in \rlangns.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Function declaration}
\NormalTok{bootstrapR <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(ds, }\DataTypeTok{B =} \DecValTok{1000}\NormalTok{) \{}
  
  \CommentTok{# Preallocate storage for statistics}
\NormalTok{  boot_stat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\DataTypeTok{nrow =}\NormalTok{ B, }\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{)}
  
  \CommentTok{# Number of observations}
\NormalTok{  n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(ds)}
  
  \CommentTok{# Perform bootstrap }
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \KeywordTok{seq_len}\NormalTok{(B)) \{}
     \CommentTok{# Sample initial data}
\NormalTok{     gen_data <-}\StringTok{ }\NormalTok{ds[ }\KeywordTok{sample}\NormalTok{(n, n, }\DataTypeTok{replace=}\OtherTok{TRUE}\NormalTok{) ]}
     \CommentTok{# Calculate sample data mean and SD}
\NormalTok{     boot_stat[i,] <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\KeywordTok{mean}\NormalTok{(gen_data),}
                        \KeywordTok{sd}\NormalTok{(gen_data))}
\NormalTok{  \}}
  
  \CommentTok{# Return bootstrap result}
  \KeywordTok{return}\NormalTok{(boot_stat)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Before continuing, check that the initial prototype \rlang code works.
To do so, write a short \rlang script. Note the use of
\texttt{set.seed()} to ensure reproducible draws.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Set seed to generate data}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{512}\NormalTok{)}
\CommentTok{# Generate data}
\NormalTok{initdata <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{1000}\NormalTok{, }\DataTypeTok{mean =} \DecValTok{21}\NormalTok{, }\DataTypeTok{sd =} \DecValTok{10}\NormalTok{)}
\CommentTok{# Set a new *different* seed for bootstrapping}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{883}\NormalTok{)}
\CommentTok{# Perform bootstrap}
\NormalTok{resultR <-}\StringTok{ }\KeywordTok{bootstrap_r}\NormalTok{(initdata)}
\end{Highlighting}
\end{Shaded}

Figure \ref{fig:bootstrap-graphs} shows that the bootstrap procedure
worked well!

\begin{figure*}
  \begin{center}
     \includegraphics[width=0.9\textwidth]{figures/dist_graphs-1} 
     \caption{\label{fig:bootstrap-graphs}
       Results of the bootstrapping procedure for sample mean and variance.}
     \label{fig:dist_graphs}
  \end{center}
\end{figure*}

With reassurances that the method to be implemented within \rcpp works
appropriately in \rlangns, proceed to translating the code into \rcppns.
As indicated previously, there are many convergences between \rcpp
syntax and base \rlang via \rcpp Sugar.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}

\CommentTok{// Function declaration with Rcpp export tag}
\CommentTok{// [[Rcpp::export]]}
\NormalTok{Rcpp::NumericMatrix}
\NormalTok{bootstrapCpp(Rcpp::NumericVector ds,}
              \DataTypeTok{int}\NormalTok{ B = }\DecValTok{1000}\NormalTok{) \{}
  
  \CommentTok{// Preallocate storage for statistics}
\NormalTok{  Rcpp::NumericMatrix boot_stat(B, }\DecValTok{2}\NormalTok{);}
  
  \CommentTok{// Number of observations}
  \DataTypeTok{int}\NormalTok{ n = ds.size();}
  
  \CommentTok{// Perform bootstrap }
  \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < B; i++) \{}
    \CommentTok{// Sample initial data }
\NormalTok{    Rcpp::NumericVector}
\NormalTok{    gen_data = ds[ floor(Rcpp::runif(n, }\DecValTok{0}\NormalTok{, n)) ]; }
    \CommentTok{// Calculate sample data mean and std dev}
\NormalTok{    boot_stat(i, }\DecValTok{0}\NormalTok{) = mean(gen_data);             }
\NormalTok{    boot_stat(i, }\DecValTok{1}\NormalTok{) = sd(gen_data);}
\NormalTok{  \}}
  
  \CommentTok{// Return bootstrap results}
  \ControlFlowTok{return}\NormalTok{ boot_stat;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In the \rcpp version of the bootstrap function, there are a few
additional changes that occurred during the translation. In particular,
the use of \texttt{Rcpp::runif(n,\ 0,\ n)} enclosed by \texttt{floor()},
which rounds down to the nearest integer, in place of
\texttt{sample(n,\ n,\ replace\ =\ TRUE)} to sample row ids. This is an
equivalent substitution since equal weight is being placed upon all row
ids and replacement is
allowed.\footnote{For more flexibility in sampling see Christian Gunning's
Sample extension for \pkg{RcppArmadillo} and 
\href{http://gallery.rcpp.org/articles/using-the-Rcpp-based-sample-implementation/}{Rcpp Gallery: Using the \pkg{RcppArmadillo}-based Implementation of R's sample()} or consider using the \code{Rcpp::sample()} sugar function added in 0.12.9 by Nathan Russell.}
Note that the upper bound of the interval, \texttt{n}, will never be
reached. While this may seem flawed, it is important to note that
vectors and matrices in \cpp use a zero-based indexing system, meaning
that they begin at 0 instead of 1 and go up to \(n-1\) instead of \(n\),
which is unlike \rlangns's system. Thus, an out of bounds error would be
triggered if \texttt{n} was used as that point does \emph{not} exist
within the data structure. The application of this logic can be seen in
the span the \texttt{for} loop takes in \cpp when compared to \rlangns.
Another syntactical change is the use of \texttt{()} in place of
\texttt{{[}{]}} while accessing the matrix. This change is due to the
governance of \cpp
and its comma operator making it impossible to place multiple indices
inside the square brackets.

To validate that the translation was successful, first run the
\cpp function under the \emph{same} data and seed as was given for the
\rlang function.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Use the same seed in R and C++ bootstraps}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{883}\NormalTok{)}
\CommentTok{# Perform bootstrap with C++ function}
\NormalTok{resultCpp <-}\StringTok{ }\KeywordTok{bootstrapCpp}\NormalTok{(initdata)}
\end{Highlighting}
\end{Shaded}

Next, check the output between the functions using \rlang's
\texttt{all.equal()} function that allows for an
\(\varepsilon\)-neighborhood around a number.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Compare output}
\KeywordTok{all.equal}\NormalTok{(resultR, resultCpp)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

Lastly, make sure to benchmark the newly translated \rcpp function
against the \rlang implementation. As stated earlier, data is paramount
to making a decision related to which function to use in an analysis or
package.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rbenchmark)}

\KeywordTok{benchmark}\NormalTok{(}\DataTypeTok{r =} \KeywordTok{bootstrapR} \NormalTok{(initdata), }
          \DataTypeTok{cpp =} \KeywordTok{bootstrapCpp}\NormalTok{(initdata))[, }\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   test replications elapsed relative
## 2  cpp          100   3.210    1.000
## 1    r          100   6.078    1.893
\end{verbatim}

\section{\texorpdfstring{Using \rcpp as an Interface to External
Libraries: Exploring Linear Algebra
Extensions}{Using as an Interface to External Libraries: Exploring Linear Algebra Extensions}}\label{using-as-an-interface-to-external-libraries-exploring-linear-algebra-extensions}

Many of the previously illustrated \rcpp examples were directed
primarily to show the gains in computational efficiency that are
possible by implementing code directly in \cppns; however, this is only
one potential application of \rcppns. Perhaps one of the most
understated features of \rcpp is its ability to enable
\cite{Chambers:2016:ExtR}'s third statement of \emph{Interfaces to other
software are part of \rlangns}. In particular, \rcpp is designed to
facilitate interfacing libraries written in \cpp or \clang to \rlangns.
Hence, if there is a specific feature within a \cpp or \clang library,
then one can create a bridge to it using \rcpp to enable it from within
\rlangns.

An example is the use of \cpp matrix algebra libraries like
\pkg{Armadillo} \citep{Sanderson+Curtin:2016} or \pkg{Eigen}
\citep{Eigen:Web}. By outsourcing complex linear algebra operations to
matrix libraries, the need to directly call functions within
\pkg{Linear Algebra PACKage (LAPACK)} \citep{Anderson:1990:UGLAPACK} is
negated. Moreover, the \rcpp design allows for seamless transfer between
object types by using automatic converters governed by \texttt{wrap()},
\cpp to \rlang, and \texttt{as\textless{}T\textgreater{}()}, \rlang to
\cpp with the \texttt{T} indicating the type of object being cast into.
These two helper functions provide a non-invasive way to work with an
external object. Thus, a further benefit to using external
\cpp libraries is the ability to have a portable code base that can be
implemented within a standalone \cpp program or within another
computational language.

\subsection{Compute RNG draws from a multivariate
Normal}\label{compute-rng-draws-from-a-multivariate-normal}

A common application in statistical computing is simulating from a
multivariate normal distribution. The algorithm relies on a linear
transformation of the standard Normal distribution. Letting
\(\boldsymbol{Y}_{m \times 1} = \boldsymbol{A}_{m\times n}\boldsymbol{Z}_{n\times 1} + \boldsymbol{b}_{m\times 1}\),
where \(\boldsymbol{A}\) is a \(m \times n\) matrix,
\(\boldsymbol{b} \in \mathbb{R}^m\),
\(\boldsymbol{Z} \sim N(\boldsymbol{0}_{n},\boldsymbol{I}_n)\), and
\(\boldsymbol{I}_n\) is the identity matrix, then
\({\boldsymbol{Y}} \sim N_{m}\left({\boldsymbol{\mu} = \boldsymbol{b}, \boldsymbol{\Sigma} = \boldsymbol{A}\boldsymbol{A}^T}\right)\).
To obtain the matrix \(\boldsymbol{A}\) from \(\boldsymbol{\Sigma}\),
either a Cholesky or Eigen decomposition is required. As noted in
\citet{Venables+Ripley:2002:MASS}, the Eigen decomposition is more stable in addition to
being more computationally demanding compared to the Cholesky
decomposition. For simplicity and speed, we have opted to implement the
sampling procedure using a Cholesky decomposition. Regardless, there is
a need to involve one of the above matrix libraries to make the sampling
viable in \cppns.

Here, we demonstrate how to take advantage of the \emph{Armadillo}
linear algebra template classes \citep{Sanderson+Curtin:2016} via the
\pkg{RcppArmadillo} package
\citep{Eddelbuettel+Sanderson:2013:RcppArmadillo, CRAN:RcppArmadillo}.
Prior to running this example, the \pkg{RcppArmadillo} package must be
installed using
\texttt{install.packages(\textquotesingle{}RcppArmadillo\textquotesingle{})}.\footnote{macOS
  users may encounter \texttt{-lgfortran} and \texttt{-lquadmath} errors
  on compile with this package if the development environment is not
  appropriately setup.
  \href{https://cran.r-project.org/web/packages/Rcpp/vignettes/Rcpp-FAQ.pdf\#page=8}{Section
  2.16 of Rcpp FAQ} provides details regarding the necessary
  \texttt{gfortran} binaries.} One important caveat when using
additional packages within the \rcpp ecosystem is the correct header
file may not be \texttt{Rcpp.h}. In a majority of cases, the additional
package ships a dedicated header (as \emph{e.g.}
\texttt{RcppArmadillo.h} here) which not only declares data structures
from both systems, but may also add complementary integration and
conversion routines. It typically needs to be listed in an
\texttt{include} statement along with a \texttt{depends()} attribute to
tell \rlang where to find the additional header files:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Use the RcppArmadillo package}
\CommentTok{// Requires different header file from Rcpp.h}
\PreprocessorTok{#include }\ImportTok{<RcppArmadillo.h>}
\CommentTok{// [[Rcpp::depends(RcppArmadillo)]]}
\end{Highlighting}
\end{Shaded}

With this in mind, sampling from a multivariate normal distribution can
be obtained in a straightforward manner. Using only \emph{Armadillo}
data types and values:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<RcppArmadillo.h>}
\CommentTok{// [[Rcpp::depends(RcppArmadillo)]]}

\CommentTok{// Sample N x P observations from a Standard }
\CommentTok{// Multivariate Normal given N observations, a}
\CommentTok{// vector of P means, and a P x P covariance matrix}
\CommentTok{// [[Rcpp::export]]}
\NormalTok{arma::mat rmvnorm(}\DataTypeTok{int}\NormalTok{ n, }\AttributeTok{const}\NormalTok{ arma::vec& mu, }
                  \AttributeTok{const}\NormalTok{ arma::mat& Sigma) \{}
   \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ p = Sigma.n_cols;}
    
   \CommentTok{// First draw N x P values from N(0,1)}
\NormalTok{   Rcpp::NumericVector draw = Rcpp::rnorm(n*p);}
    
   \CommentTok{// Instantiate Armadillo matrix with drawn values}
   \CommentTok{// using advan. constr to reuse allocated memory}
\NormalTok{   arma::mat Z = arma::mat(draw.begin(), n, p, }
                           \KeywordTok{false}\NormalTok{, }\KeywordTok{true}\NormalTok{);}

   \CommentTok{// Simpler, less performant alternative}
   \CommentTok{// arma::mat Z = Rcpp::as<arma::mat>(draw);}
    
   \CommentTok{// Generate a sample from the }
   \CommentTok{// Transformed Multivariate Normal}
\NormalTok{   arma::mat Y = arma::repmat(mu, }\DecValTok{1}\NormalTok{, n).t() + }
\NormalTok{                 Z * arma::chol(Sigma);}
  
    \ControlFlowTok{return}\NormalTok{ Y;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

As a result of using a random number generation (RNG), there is an
additional requirement to ensure reproducible results: the necessity to
explicitly set a seed (as shown above). Because of the (programmatic)
interface provided by \rlang to its own RNGs, this setting of the seed
has to occur at the \rlang level via the \texttt{set.seed()} function as
no (public) interface is provided by the \rlang header files.

\subsection{Faster linear model fits}\label{faster-linear-model-fits}

As a second example, consider the problem of estimating a common linear
model repeatedly. One use case might be the simulation of size and power
of standard tests. Many users of \rlang would default to using
\texttt{lm()}, however, the overhead associated with this function
greatly impacts speed with which an estimate can be obtained. Another
approach would be to take the base \rlang function \texttt{lm.fit()},
which is called by \texttt{lm()}, to compute estimated \(\hat{\beta}\)
in just about the fastest time possible. However, this approach is also
not viable as it does not report the estimated standard errors. As a
result, we cannot use any default \rlang functions in the context of
simulating finite sample population effects on inference.

One alternative is provided by the \texttt{fastLm()} function in
\pkg{RcppArmadillo} \citep{CRAN:RcppArmadillo}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<RcppArmadillo.h>}
\CommentTok{// [[Rcpp::depends(RcppArmadillo)]]}

\CommentTok{// Compute coefficients and their standard error }
\CommentTok{// during multiple linear regression given a design}
\CommentTok{// matrix X containing N observations with P }
\CommentTok{// regressors and a vector y containing of }
\CommentTok{// rN responses}
\CommentTok{// [[Rcpp::export]]}
\NormalTok{Rcpp::List fastLm(}\AttributeTok{const}\NormalTok{ arma::mat& X, }
                  \AttributeTok{const}\NormalTok{ arma::colvec& y) \{}
   \CommentTok{// Dimension information}
   \DataTypeTok{int}\NormalTok{ n = X.n_rows, p = X.n_cols;}
    
   \CommentTok{// Fit model y ~ X }
\NormalTok{   arma::colvec coef = arma::solve(X, y);    }
    
   \CommentTok{// Compute the residuals }
\NormalTok{   arma::colvec res  = y - X*coef;           }

   \CommentTok{// Obtain the est. var of the random error }
   \DataTypeTok{double}\NormalTok{ s2 = }
       \BuiltInTok{std::}\NormalTok{inner_product(res.begin(), res.end(),}
\NormalTok{                          res.begin(), }\FloatTok{0.0}\NormalTok{)/(n - p);}
    
   \CommentTok{// Obtain the std error matrix of coefficients}
\NormalTok{   arma::colvec std_err =}
\NormalTok{       arma::sqrt(s2 * }
\NormalTok{           arma::diagvec(arma::pinv(X.t()*X)));}

   \CommentTok{// Create a named list with the above quantities}
   \ControlFlowTok{return} \NormalTok{ Rcpp::List::create(}
\NormalTok{             Rcpp::Named(}\StringTok{"coefficients"}\NormalTok{) = coef,}
\NormalTok{             Rcpp::Named(}\StringTok{"stderr"}\NormalTok{)       = std_err,}
\NormalTok{             Rcpp::Named(}\StringTok{"df.residual"}\NormalTok{)  = n - p  );}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The interface is very simple: a matrix \(X_{n \times p}\) of regressors,
and a dependent variable \(y_{n \times 1}\) as a vector. We invoke the
standard Armadillo function \texttt{solve()} to fit the model
\texttt{y\ \textasciitilde{}\ X}.\footnote{We should note
that this will use the standard \pkg{LAPACK} functionality via Armadillo whereas R
uses an internal refinement of \pkg{LINPACK} \citep{Dongarra:1979:UGLINPACK} via pivoting,
rendering the operation numerically more stable.  That is an important
robustness aspect---though common datasets on current hardware almost
never lead to actual differences.  That said, if in doubt, stick with
the R implementation.  What is shown here is mostly for exposition of
the principles.} We then compute residuals, and extract the
(appropriately scaled) diagonal of the covariance matrix, also taking
its square root, in order to return both estimates \(\hat{\beta}\) and
\(\hat{\sigma}\).

\section{\texorpdfstring{\rcpp in
Packages}{in Packages}}\label{in-packages}

Once a project containing compiled code has matured to the point of
sharing it with
collaborators\footnote{It is sometimes said that every project has two collaborators:
self, and future self. Packaging code is \textsl{best practices} even for code not
intended for public uploading.} or using it within a parallel computing
environments, the ideal way forward is to embed the code within an
\rlang package. Not only does an \rlang
package provide a way to automatically compile source code, but also
enables the use of the \rlang help system to document how the written
functions should be used. As a further benefit, the package format
enables the use of unit tests to ensure that the functions are producing
the correct output. Lastly, having a package provides the option of
uploading to a repository such as CRAN for wider dissemination.

To facilitate package building, \rcpp provides a function
\texttt{Rcpp.package.skeleton()} that is modeled after the base
\rlang function \texttt{package.skeleton()}. This function automates the
creation of a skeleton package appropriate for distributing \rcppns:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"Rcpp"}\NormalTok{)}
\KeywordTok{Rcpp.package.skeleton}\NormalTok{(}\StringTok{"samplePkg"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.9\columnwidth]{figures/samplePkg-files-light-bg} \end{center}

This shows how distinct directories \texttt{man}, \texttt{R},
\texttt{src} are created for, respectively, the help pages, files with
\rlang code and files with \cpp code. Generally speaking, all compiled
code, be it from \clangns, \cpp or \fortran sources, should be placed
within the \texttt{src/} directory.

Alternatively, one can achieve similar results to using
\texttt{Rcpp.package.skeleton()} by using a feature of the RStudio IDE.
Specifically, while creating a new package project there is an option to
select the type of package by engaging a dropdown menu to select
``Package w/ Rcpp'' in RStudio versions prior to v1.1.0. In RStudio
versions later than v1.1.0, support for package templates has been added
allowing users to directly create \rcppns-based packages that use Eigen
or Armadillo.

Lastly, one more option exists for users who are familiar with the
\pkg{devtools} \rlang package by \cite{CRAN:devtools}. To create the
\rlang package skeleton use \texttt{devtools::create("samplePkg")}. From
here, part of the structure required by \rcpp can be added by using
\texttt{devtools::use\_rcpp()}. The remaining aspects needed by
\rcpp must be manually copied from the roxygen tags written to console
and pasted into one of the package's \rlang
files to successfully incorporate the dynamic library and link to
\rcppns's headers.

All of these methods take care of a number of small settings one would
have to enable manually otherwise. These include an `Imports:' and
`LinkingTo:' declaration in file DESCRIPTION, as well as `useDynLib' and
`importFrom' in NAMESPACE. For \emph{Rcpp Attributes} use, the
\texttt{compileAttributes()} function has to be called. Similarly, to
take advantage of its documentation-creation feature, the
\texttt{roxygenize()} function from \pkg{roxygen2} has to be
called.\footnote{The \pkg{littler} package \citep{CRAN:littler} has a helper script `roxy.r`
for this.} Additional details on using \rcpp within a package scope are
detailed in \citet{CRAN:Rcpp:Package}.

\section{Conclusion}\label{conclusion}

\rlang has always provided mechanisms to extend it. The bare-bones
\clang API is already used to great effect by a large number of
packages. By taking advantage of a number of \cpp
features, \rcpp has been able to make extending \rlang easier, offering
a combination of both speed \emph{and} ease of use that has been finding
increasingly widespread utilization by researchers and data scientists.
We are thrilled about this adoption, and look forward to seeing more
exciting extensions to \rlang being built.


\showmatmethods 

\acknow{We thank Bob Rudis and Lionel Henry for comments and suggestion on an
earlier draft of this manuscript. Furthermore, we appreciate the
improved \cpp  annotated function graphic provided by Bob Rudis.}

\showacknow 

\pnasbreak

\bibliography{\Sexpr{Rcpp:::bib()}}

\end{document}

